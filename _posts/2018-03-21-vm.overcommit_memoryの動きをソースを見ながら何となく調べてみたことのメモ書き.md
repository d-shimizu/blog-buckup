---
layout: post
Categories:  ["tech"]
Description:  " Linuxのカーネルパラメータvm.overcommit_memory=2(メモリのオーバーコミットをさせない設定)の時、vm.overcommit_ratioの値を99とかではなく、カーネルが使うメモリを確保するために80とかにして余裕"
Tags: ["Linux", "tech"]
date: "2018-03-21T22:53:00+09:00"
title: "vm.overcommit_memoryの動きをソースを見ながら何となく調べてみたことのメモ書き"
author: "dshimizu"
archive: ["2018"]
draft: "true"
---

<body>
<p><a class="keyword" href="http://d.hatena.ne.jp/keyword/Linux">Linux</a>の<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%AB%A1%BC%A5%CD%A5%EB">カーネル</a>パラメータ<code>vm.overcommit_memory=2</code>(メモリのオーバーコミットをさせない設定)の時、<code>vm.overcommit_ratio</code>の値を<code>99</code>とかではなく、<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%AB%A1%BC%A5%CD%A5%EB">カーネル</a>が使うメモリを確保するために<code>80</code>とかにして余裕を持たせておく必要があるとかないとかの話になって、結局のところどうなっているのか、現時点での最新<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%AB%A1%BC%A5%CD%A5%EB">カーネル</a>をなんとなく読みながら調べてみたので書いておく。</p>
</body>

<!-- more -->

<body>
<h3>オーバーコミットとその制限</h3>


<p>そもそもオーバーコミットとは何ぞやというと、プロセスがメモリを確保するとき、各プロセスごとに<a class="keyword" href="http://d.hatena.ne.jp/keyword/%B2%BE%C1%DB%A5%E1%A5%E2%A5%EA">仮想メモリ</a>空間が割り当てられる。その時、<a class="keyword" href="http://d.hatena.ne.jp/keyword/x86">x86</a>では4GB、<a class="keyword" href="http://d.hatena.ne.jp/keyword/x86">x86</a>_64では128TBの仮想<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%A2%A5%C9%A5%EC%A5%B9%B6%F5%B4%D6">アドレス空間</a>を利用でき、実際の物理メ<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%E2%A5%EA%A1%BC">モリー</a>より大きな値を扱う(≒オーバーコミットする)ことになる...という認識。</p>

<p>これでは困ることがあるため、オーバーコミットを制限するための<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%AB%A1%BC%A5%CD%A5%EB">カーネル</a>パラメータが<code>vm.overcommit_memory</code>で、プロセス全体で使用できる<a class="keyword" href="http://d.hatena.ne.jp/keyword/%B2%BE%C1%DB%A5%E1%A5%E2%A5%EA">仮想メモリ</a>空間を、物理メモリ量を超えないように制限するための制限値が<code>2</code>である...と思っている。</p>

<h3>
<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%BD%A1%BC%A5%B9%A5%B3%A1%BC%A5%C9">ソースコード</a>を見てみる</h3>


<p>とりあえず<a class="keyword" href="http://d.hatena.ne.jp/keyword/GitHub">GitHub</a>に上がっている<a class="keyword" href="http://d.hatena.ne.jp/keyword/Linux">Linux</a><a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%AB%A1%BC%A5%CD%A5%EB">カーネル</a>の<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%BD%A1%BC%A5%B9%A5%B3%A1%BC%A5%C9">ソースコード</a>を読んでみることにした。
この時の<a class="keyword" href="http://d.hatena.ne.jp/keyword/Linux">Linux</a><a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%AB%A1%BC%A5%CD%A5%EB">カーネル</a>のバージョンは <a class="keyword" href="http://d.hatena.ne.jp/keyword/Linux">Linux</a> Kernel 4.16 RC のものだったと思う。</p>

<p><code>overcommit_memory</code>とかで<a class="keyword" href="http://d.hatena.ne.jp/keyword/grep">grep</a>しながら追ってみると該当部分の処理は<code>linux/mm/util.c</code>の<code>__vm_enough_memory()</code>というところらへんに何かあった。
コメントの記載をみると、仮想<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%A2%A5%C9%A5%EC%A5%B9%B6%F5%B4%D6">アドレス空間</a>を物理メモリに<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%DE%A5%C3%A5%D4%A5%F3%A5%B0">マッピング</a>するときに、十分なメモリがあるかどうかチェックしているもののようだった。</p>

<p><code>__vm_enough_memory()</code>関数の最初の <code>vm_acct_memory(pages);</code>で Committed_AS が加算され、<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%AB%A1%BC%A5%CD%A5%EB">カーネル</a>パラメータ<code>vm.overcommit_memory</code>の値によって処理を分岐させている模様。</p>

<p><code>OVERCOMMIT_NEVER</code>(<code>vm.overcommit_memory=2</code>つまりオーバーコミットしない)の場合は同一ファイル内の<code>vm_commit_limit()</code>が呼び出されている。</p>

<pre class="terminal"> /*
 * Check that a process has enough memory to allocate a new virtual
 * mapping. 0 means there is enough memory for the allocation to
 * succeed and -ENOMEM implies there is not.
 *
 * We currently support three overcommit policies, which are set via the
 * vm.overcommit_memory sysctl.  See Documentation/vm/overcommit-accounting
 *
 * Strict overcommit modes added 2002 Feb 26 by Alan Cox.
 * Additional code 2002 Jul 20 by Robert Love.
 *
 * cap_sys_admin is 1 if the process has admin privileges, 0 otherwise.
 *
 * Note this is a helper function intended to be used by LSMs which
 * wish to use this logic.
 */
int __vm_enough_memory(struct mm_struct *mm, long pages, int cap_sys_admin)
{
    long allowed;

    VM_WARN_ONCE(percpu_counter_read(&amp;vm_committed_as) &lt;
            -(s64)vm_committed_as_batch * num_online_cpus(),
            "memory commitment underflow");

    vm_acct_memory(pages);

    /*
     * Sometimes we want to use more memory than we have
     */
    if (sysctl_overcommit_memory == OVERCOMMIT_ALWAYS)
        return 0;

    if (sysctl_overcommit_memory == OVERCOMMIT_GUESS) {
        free = global_zone_page_state(NR_FREE_PAGES);
        free += global_node_page_state(NR_FILE_PAGES);

        /*
         * shmem pages shouldn't be counted as free in this
         * case, they can't be purged, only swapped out, and
         * that won't affect the overall amount of available
         * memory in the system.
         */
        free -= global_node_page_state(NR_SHMEM);

        free += get_nr_swap_pages();

        /*
         * Any slabs which are created with the
         * SLAB_RECLAIM_ACCOUNT flag claim to have contents
         * which are reclaimable, under pressure.  The dentry
         * cache and most inode caches should fall into this
         */
        free += global_node_page_state(NR_SLAB_RECLAIMABLE);

        /*
         * Part of the kernel memory, which can be released
         * under memory pressure.
         */
        free += global_node_page_state(NR_KERNEL_MISC_RECLAIMABLE);

        /*
         * Leave reserved pages. The pages are not for anonymous pages.
         */
        if (free &lt;= totalreserve_pages)
            goto error;
        else
            free -= totalreserve_pages;
        
        
        /*
         * Reserve some for root
         */
        if (!cap_sys_admin)
            free -= sysctl_admin_reserve_kbytes &gt;&gt; (PAGE_SHIFT - 10);

        if (free &gt; pages)
            return 0;

        goto error;
    }


    allowed = vm_commit_limit();
    /*
     * Reserve some for root
     */
    if (!cap_sys_admin)
        allowed -= sysctl_admin_reserve_kbytes &gt;&gt; (PAGE_SHIFT - 10);

    /*
     * Don't let a single process grow so big a user can't recover
     */
    if (mm) {
        reserve = sysctl_user_reserve_kbytes &gt;&gt; (PAGE_SHIFT - 10);
        allowed -= min_t(long, mm-&gt;total_vm / 32, reserve);
    }

    if (percpu_counter_read_positive(&amp;vm_committed_as) &lt; allowed)
        return 0;
error:
    vm_unacct_memory(pages);

    return -ENOMEM;

}
    :
    :
    :
/*
 * Committed memory limit enforced when OVERCOMMIT_NEVER policy is used
 */
unsigned long vm_commit_limit(void)
{
    unsigned long allowed;

    if (sysctl_overcommit_kbytes)
        allowed = sysctl_overcommit_kbytes &gt;&gt; (PAGE_SHIFT - 10);
    else
        allowed = ((totalram_pages - hugetlb_total_pages())
               * sysctl_overcommit_ratio / 100);
    allowed += total_swap_pages;

    return allowed;
}
 </pre>


<p><code>vm_acct_memory()</code>関数は<code>include/linux/mman.h</code>に定義されている。</p>

<pre class="terminal"> static inline void vm_acct_memory(long pages)
{
    percpu_counter_add_batch(&amp;vm_committed_as, pages, vm_committed_as_batch);
}

static inline void vm_unacct_memory(long pages)
{
    vm_acct_memory(-pages);
}
 </pre>


<p><a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%AB%A1%BC%A5%CD%A5%EB">カーネル</a>パラメータ<code>vm.overcommit_memory</code>の値を各条件分岐で見て<code>overcommit</code>できるなら<code>0</code>を、できないようなら<code>-ENOMEM</code>を返すようになっているように見える。
<code>overcommit</code>ができない場合というのは、設定で許可されていないか<code>overcommit</code>できるかどうか計算した結果NGだった場合、のいずれかの模様。
<code>vm.overcommit_memory=2</code>の場合、<code>vm.overcommit_kbytes</code>か<code>&gt;vm.overcommit_ratio</code>のどちらかの値が有効になる(両方指定した場合にどちらが有効になるかは未検証)。
<code>sysctl_overcommit_kbytes</code>が設定されていない場合は<code>allowed = ((totalram_pages - hugetlb_total_pages()) * sysctl_overcommit_ratio / 100);</code>で割り当て可能なメモリ量が算出されている。詳しい仕組みはわかっていない</p>

<p><code>vm.overcommit_memory=0</code> or <code>vm.overcommit_memory=2</code>の場合は、<code>if(!cap_sys_admin)</code>でプロセスに管理者権限があるかどうかチェックされており、<code>cap_sys_admin</code>が0の時、つまり管理者権限がない時には<code>admin_reserve_kbytes</code>分のメモリが<code>allow</code>からマイナスされて確保されるようになっているっぽい。
(<code>vm.overcommit_memory=0</code>のときは free として、<code>vm.overcommit_memory=2</code>のときは予約ページとして確保されている？)
また、その後、<code>reserve = sysctl_user_reserve_kbytes &gt;&gt; (PAGE_SHIFT - 10);</code>で1つユーザプロセスが肥大化しないように<code>vm.user_reserve_kbytes</code>分の値を確保していた。</p>

<p>最後の<code>if (percpu_counter_read_positive(&amp;vm_committed_as) &lt; allowed)</code>の部分で、committed_asの値がallowed(≒CommitLimit)を越えなければ大丈夫ということらしい。</p>

<p>いろいろたどっていくと<code>__vm_enough_memory()</code>は<code>security/security.c</code>内の<code>security_vm_enough_memory_mm()</code>で呼ばれていた。</p>

<pre class="terminal"> int security_vm_enough_memory_mm(struct mm_struct *mm, long pages)
{
    struct security_hook_list *hp;
    int cap_sys_admin = 1;
    int rc;

    /*
     * The module will respond with a positive value if
     * it thinks the __vm_enough_memory() call should be
     * made with the cap_sys_admin set. If all of the modules
     * agree that it should be set it will. If any module
     * thinks it should not be set it won't.
     */
    hlist_for_each_entry(hp, &amp;security_hook_heads.vm_enough_memory, list) {
        rc = hp-&gt;hook.vm_enough_memory(mm, pages);
        if (rc &lt;= 0) {
            cap_sys_admin = 0;
            break;
        }
    }
    return __vm_enough_memory(mm, pages, cap_sys_admin);
}
 </pre>


<p><code>admin_reserve_kbytes</code>はドキュメント(<code>/Documentation/sysctl/vm.txt</code>)に記載があった。
<code>vm.overcommit_memory=2</code>とした時、何かあった場合に管理者がログインしてプロセスを強制終了したりできるようにするためには、<a class="keyword" href="http://d.hatena.ne.jp/keyword/sshd">sshd</a>またはlogin + <a class="keyword" href="http://d.hatena.ne.jp/keyword/bash">bash</a>あたりが実行できるサイズを確保できるよう十分な値に調整する必要がある値のようだ。</p>

<pre class="docs"> admin_reserve_kbytes

The amount of free memory in the system that should be reserved for users
with the capability cap_sys_admin.

admin_reserve_kbytes defaults to min(3% of free pages, 8MB)

That should provide enough for the admin to log in and kill a process,
if necessary, under the default overcommit 'guess' mode.

Systems running under overcommit 'never' should increase this to account
for the full Virtual Memory Size of programs used to recover. Otherwise,
root may not be able to log in to recover the system.

How do you calculate a minimum useful reserve?

sshd or login + bash (or some other shell) + top (or ps, kill, etc.)

For overcommit 'guess', we can sum resident set sizes (RSS).
On x86_64 this is about 8MB.

For overcommit 'never', we can take the max of their virtual sizes (VSZ)
and add the sum of their RSS.
On x86_64 this is about 128MB.

Changing this takes effect whenever an application requests memory.

==============================================================
 </pre>


<p><code>user_reserve_kbytes</code>はドキュメント(<code>/Documentation/sysctl/vm.txt</code>)を見ると、ユーザープロセスがメ<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%E2%A5%EA%A1%BC">モリー</a>を占有しないようにあらかじめ予約しておくためのもののようだった。</p>

<pre class="docs"> - user_reserve_kbytes

When overcommit_memory is set to 2, "never overcommit" mode, reserve
min(3% of current process size, user_reserve_kbytes) of free memory.
This is intended to prevent a user from starting a single memory hogging
process, such that they cannot recover (kill the hog).

user_reserve_kbytes defaults to min(3% of the current process size, 128MB).

If this is reduced to zero, then the user will be allowed to allocate
all free memory with a single process, minus admin_reserve_kbytes.
Any subsequent attempts to execute a command will result in
"fork: Cannot allocate memory".

Changing this takes effect whenever an application requests memory.

==============================================================
 </pre>


<p>ちなみにUbuntu16.04で見ると、デフォルト値のパラメータは<code>vm.overcommit_memory=0</code>で<code>vm.admin_reserve_kbytes=8192</code>でドキュメントの通りだった。</p>

<pre class="terminal"> vm.admin_reserve_kbytes = 8192
vm.overcommit_kbytes = 0
vm.overcommit_memory = 0
vm.overcommit_ratio = 50
 </pre>


<h3>まとめ</h3>


<p><code>vm.overcommit_memory</code>の値における挙動について<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%BD%A1%BC%A5%B9%A5%B3%A1%BC%A5%C9">ソースコード</a>を読みながら調べてみた。</p>

<ol>
    <li>
<code>__vm_enough_memory()</code>の最初の <code>vm_acct_memory(pages);</code>で Committed_AS が加算される。ようだが、厳密にどういう処理が行われているのかはまだ見ていない。</li>
    <li>
<code>user_reserve_kbytes</code>で1つのプロセスが肥大化しないような制御や、<code>admin_reserve_kbytes</code>で管理者用のメモリ領域が確保される動きになっているように思う。(が、その理解で合っているのかわからない。)</li>
</ol>


<p>ということで、<code>overcommit_ratio</code>の値は、特に<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%AB%A1%BC%A5%CD%A5%EB">カーネル</a>で使用するメモリのことを考える必要はないのでは？と思っている。</p>

<p>ただ、ドキュメントによると、オーバーコミットできないときにメモリ不足等になった場合に備えるには<code>vm.admin_reserve_kbytes</code>の値を、場合によっては<a class="keyword" href="http://d.hatena.ne.jp/keyword/sshd">sshd</a>や<a class="keyword" href="http://d.hatena.ne.jp/keyword/bash">bash</a>が実行できる程度のメモリを確保できるように確認して必要に応じて調整しておいた方が良いかもしれない。</p>

<h3>参考</h3>


<ul>
    <li><a href="https://github.com/torvalds/linux/blob/master/mm/util.c" target="_brank" rel="noopener noreferrer">linux/util.c at master · torvalds/linux · GitHub</a></li>
    <li><a href="https://github.com/torvalds/linux/blob/master/Documentation/sysctl/vm.txt" target="_brank" rel="noopener noreferrer">linux/vm.txt at master · torvalds/linux · GitHub</a></li>
    <li><a href="https://kernhack.hatenablog.com/entry/2015/12/23/135008" target="_brank" rel="noopener noreferrer">glibcのmalloc(3)とLinuxカーネルのovercommitとOOM - φ(・・*)ゞ ｳｰﾝ　カーネルとか弄ったりのメモ</a></li>
    <li><a href="https://stackoverflow.com/questions/38688824/linux-over-commit-heuristic" target="_brank" rel="noopener noreferrer">memory management - Linux over commit heuristic - Stack Overflow</a></li>
    <li><a href="https://linuxjm.osdn.jp/html/LDP_man-pages/man5/proc.5.html" target="_brank" rel="noopener noreferrer">Man page of PROC</a></li>
    <li><a target="_brank" rel="noopener noreferrer" href="https://www.kernel.org/doc/Documentation/vm/hugetlbpage.txt">Documentation/vm/hugetlbpage.txt</a></li>
    <li><a target="_brank" rel="noopener noreferrer" href="https://github.com/hiboma/hiboma/blob/master/kernel/mm/vm.overcommit%E3%81%AE%E8%AA%BF%E3%81%B8%E3%82%99%E3%82%82%E3%81%AE.md">hiboma/vm.overcommitの調べもの.md at master · hiboma/hiboma</a></li>
</ul>

</body>
